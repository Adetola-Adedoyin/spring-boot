name: CI/CD Pipeline

on:
  push:
    branches: [master]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  TF_VERSION: 1.8.0

jobs:

  terraform-init-plan:
    name: Terraform Init & Plan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform init

      - name: Terraform Validate
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform validate

      - name: Check for existing key pairs
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          # Check if any key pairs with our prefix exist and delete them
          existing_keys=$(aws ec2 describe-key-pairs --query 'KeyPairs[?starts_with(KeyName, `springboot-devops-dev-keypair-`)].KeyName' --output text --region ${{ env.AWS_REGION }} || echo "")
          if [ ! -z "$existing_keys" ]; then
            echo "Found existing key pairs: $existing_keys"
            for key in $existing_keys; do
              echo "Deleting existing key pair: $key"
              aws ec2 delete-key-pair --key-name "$key" --region ${{ env.AWS_REGION }}
            done
          fi

      - name: Terraform Plan
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform plan -out=tfplan

      - name: Save Terraform Plan and State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-state
          path: |
            devops-springboot-infra/terraform/envs/dev/tfplan
            devops-springboot-infra/terraform/envs/dev/.terraform/
            devops-springboot-infra/terraform/envs/dev/*.tf
            devops-springboot-infra/terraform/envs/dev/*.tfvars
            devops-springboot-infra/terraform/envs/dev/terraform.tfstate*
          retention-days: 1


  approval-apply:
    name: Wait for Approval Before Apply
    runs-on: ubuntu-latest
    needs: terraform-init-plan
    environment:
      name: apply-approval
    steps:
      - name: Approval Gate
        run: |
          echo "ğŸ” Terraform plan completed successfully"
          echo "ğŸ‘€ Please review the plan and approve to proceed with infrastructure provisioning"
          echo "ğŸ“‹ This will create/modify AWS resources as defined in the Terraform configuration"


  terraform-apply-and-deploy:
    name: Terraform Apply and Deploy App
    runs-on: ubuntu-latest
    needs: approval-apply
    outputs:
      ec2_ip: ${{ steps.get_ip.outputs.ec2_ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Download Terraform Plan and State
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-state
          path: devops-springboot-infra/terraform/envs/dev

      - name: List Terraform Files (Debug)
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          echo "ğŸ“ Terraform directory contents:"
          ls -la
          echo "ğŸ“ .terraform directory:"
          ls -la .terraform/ || echo "No .terraform directory"

      - name: Terraform Init
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform init

      - name: Terraform Apply
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform apply -auto-approve tfplan

      - name: Debug Terraform State
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          echo "ğŸ“Š Terraform state list:"
          terraform state list || echo "No state found"
          echo "ğŸ“Š Available outputs:"
          terraform output || echo "No outputs found"

      - name: Get EC2 IP
        id: get_ip
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          # Refresh state to ensure outputs are available
          terraform refresh
          
          # Check if output exists first
          if terraform output ec2_public_ip &>/dev/null; then
            EC2_IP=$(terraform output -raw public_ip)
            echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
            echo "ğŸŒ EC2 Public IP: $EC2_IP"
          else
            echo "âŒ Error: public_ip output not found in Terraform state"
            echo "Please ensure your Terraform configuration includes the required outputs:"
            echo "output \"public_ip\" { value = aws_instance.web.public_ip }"
            terraform output
            exit 1
          fi

      - name: Extract Private Key
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          # Check if private key output exists
          if terraform output private_key_pem &>/dev/null; then
            terraform output -raw private_key_pem > private_key.pem
            chmod 600 private_key.pem
            echo "ğŸ” Private key extracted and secured"
          else
            echo "âŒ Error: private_key_pem output not found in Terraform state"
            echo "Please ensure your Terraform configuration includes:"
            echo "output \"private_key_pem\" { value = tls_private_key.dev.private_key_pem; sensitive = true }"
            terraform output
            exit 1
          fi

      - name: Wait for EC2 Instance to be Ready
        run: |
          echo "â³ Waiting for EC2 instance to be fully ready..."
          sleep 30

      - name: SSH and Start Spring Boot App
        run: |
          EC2_IP="${{ steps.get_ip.outputs.ec2_ip }}"
          echo "ğŸš€ Deploying application to EC2 instance: $EC2_IP"
          
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 \
              -i devops-springboot-infra/terraform/envs/dev/private_key.pem ubuntu@$EC2_IP << 'EOF'
            echo "ğŸ“¦ Starting Spring Boot application service..."
            
            # Check if service exists and start it
            if systemctl list-unit-files | grep -q springboot-app.service; then
              echo "âœ… Service found, starting springboot-app.service"
              sudo systemctl start springboot-app.service
              sudo systemctl enable springboot-app.service
              
              # Check service status
              sudo systemctl status springboot-app.service --no-pager
              
              echo "ğŸ‰ Spring Boot application deployed successfully!"
            else
              echo "âš ï¸  springboot-app.service not found. Please ensure the service is properly configured."
              exit 1
            fi
          EOF

      - name: Verify Deployment
        run: |
          EC2_IP="${{ steps.get_ip.outputs.ec2_ip }}"
          echo "ğŸ” Verifying application deployment..."
          echo "ğŸ“ Application should be accessible at: http://$EC2_IP:8080"

      - name: Save Complete Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-complete-state
          path: |
            devops-springboot-infra/terraform/envs/dev/terraform.tfstate
            devops-springboot-infra/terraform/envs/dev/terraform.tfstate.backup
            devops-springboot-infra/terraform/envs/dev/.terraform/
            devops-springboot-infra/terraform/envs/dev/*.tf
            devops-springboot-infra/terraform/envs/dev/*.tfvars
          retention-days: 1


  manual-destroy-approval:
    name: Manual Approval to Destroy
    runs-on: ubuntu-latest
    needs: terraform-apply-and-deploy
    environment:
      name: destroy-approval
    steps:
      - name: Wait for Approval to Destroy
        run: |
          echo "ğŸ—ï¸  Infrastructure and application deployment completed successfully"
          echo "ğŸ’° Approve this step to destroy the infrastructure and save costs"
          echo "âš ï¸  This will completely tear down all AWS resources"
          echo "ğŸ“ EC2 Instance IP: ${{ needs.terraform-apply-and-deploy.outputs.ec2_ip }}"


  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    needs: manual-destroy-approval
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-complete-state
          path: devops-springboot-infra/terraform/envs/dev

      - name: Terraform Init
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: terraform init

      - name: Terraform Destroy
        working-directory: devops-springboot-infra/terraform/envs/dev
        run: |
          echo "ğŸ’¥ Destroying infrastructure..."
          terraform destroy -auto-approve
          echo "âœ… Infrastructure destroyed successfully"

      - name: Cleanup
        run: |
          echo "ğŸ§¹ Cleaning up sensitive artifacts..."
          rm -f private_key.pem
          echo "âœ… Cleanup completed"
