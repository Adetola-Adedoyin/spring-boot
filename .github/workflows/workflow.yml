name: Spring Boot Infrastructure CI/CD Pipeline

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  TF_VERSION: "1.5.0"
  AWS_REGION: "us-east-1"
  TF_VAR_region: "us-east-1"

jobs:
  # üü¶ Stage 1: Terraform Init & Plan
  terraform-plan:
    name: "Terraform Plan"
    runs-on: ubuntu-latest
    outputs:
      tfplan-exists: ${{ steps.plan.outputs.tfplan-exists }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -out=tfplan
          echo "tfplan-exists=true" >> $GITHUB_OUTPUT

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: tfplan
          retention-days: 1

      - name: Upload Terraform State Files
        uses: actions/upload-artifact@v4
        with:
          name: terraform-files
          path: |
            .terraform/
            *.tf
            *.tfvars
          retention-days: 1

  approve-apply:
    name: "Manual Approval - Apply Infrastructure"
    runs-on: ubuntu-latest
    needs: terraform-plan
    environment: 
      name: apply-approval
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: Manual Approval Required
        run: |
          echo " Terraform plan completed successfully"
          echo " Please review the plan and approve to proceed with infrastructure provisioning"
          echo " This will create/modify AWS resources as defined in the Terraform configuration"

  terraform-apply:
    name: "Terraform Apply & Extract Outputs"
    runs-on: ubuntu-latest
    needs: [terraform-plan, approve-apply]
    outputs:
      ec2-public-ip: ${{ steps.extract-outputs.outputs.ec2-public-ip }}
      private-key-written: ${{ steps.extract-outputs.outputs.private-key-written }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan

      - name: Download Terraform Files
        uses: actions/download-artifact@v4
        with:
          name: terraform-files

      - name: Terraform Init
        run: terraform init

      - name: Terraform Apply
        run: terraform apply tfplan

      - name: Extract Terraform Outputs
        id: extract-outputs
        run: |
          # Extract EC2 public IP
          EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip)
          echo "ec2-public-ip=$EC2_PUBLIC_IP" >> $GITHUB_OUTPUT
          echo " EC2 Public IP: $EC2_PUBLIC_IP"
          
          # Extract private key and write to file
          terraform output -raw private_key_pem > private_key.pem
          chmod 600 private_key.pem
          echo "private-key-written=true" >> $GITHUB_OUTPUT
          echo " Private key extracted and secured"

      - name: Upload Private Key
        uses: actions/upload-artifact@v4
        with:
          name: private-key
          path: private_key.pem
          retention-days: 1

      - name: Upload Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: |
            terraform.tfstate
            .terraform/
          retention-days: 1

  deploy-application:
    name: "Deploy Spring Boot Application"
    runs-on: ubuntu-latest
    needs: terraform-apply
    
    steps:
      - name: Download Private Key
        uses: actions/download-artifact@v4
        with:
          name: private-key

      - name: Setup SSH Key
        run: |
          chmod 600 private_key.pem
          eval $(ssh-agent -s)
          ssh-add private_key.pem

      - name: Wait for EC2 Instance to be Ready
        run: |
          echo "‚è≥ Waiting for EC2 instance to be fully ready..."
          sleep 30

      - name: Deploy Spring Boot Application
        run: |
          EC2_IP="${{ needs.terraform-apply.outputs.ec2-public-ip }}"
          
          # SSH options for strict host key checking
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30"
          
          echo " Deploying application to EC2 instance: $EC2_IP"
          
          # Connect to EC2 and start the Spring Boot service
          ssh $SSH_OPTS -i private_key.pem ec2-user@$EC2_IP << 'EOF'
            echo " Starting Spring Boot application service..."
            
            # Check if service exists
            if systemctl list-unit-files | grep -q springboot-app.service; then
              echo "‚úÖService found, starting springboot-app.service"
              sudo systemctl start springboot-app.service
              sudo systemctl enable springboot-app.service
              
              # Check service status
              sudo systemctl status springboot-app.service
              
              echo " Spring Boot application deployed successfully!"
            else
              echo " springboot-app.service not found. Please ensure the service is properly configured."
              exit 1
            fi
          EOF

      - name: Verify Application Deployment
        run: |
          EC2_IP="${{ needs.terraform-apply.outputs.ec2-public-ip }}"
          echo " Verifying application deployment..."
          echo " Application should be accessible at: http://$EC2_IP:8080"
          
          # Optional: Add health check
          # curl -f http://$EC2_IP:8080/actuator/health || echo "Health check failed"

  approve-destroy:
    name: "Manual Approval - Destroy Infrastructure"
    runs-on: ubuntu-latest
    needs: deploy-application
    environment: 
      name: destroy-approval
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: Manual Approval Required
        run: |
          echo " Infrastructure and application deployment completed successfully"
          echo "Approve this step to destroy the infrastructure and save costs"
          echo "This will completely tear down all AWS resources"
          echo "EC2 Instance IP: ${{ needs.terraform-apply.outputs.ec2-public-ip }}"

    terraform-destroy:
    - name: "Terraform Destroy"
      runs-on: ubuntu-latest
      needs: [terraform-apply, approve-destroy]
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state

      - name: Terraform Init
        run: terraform init

      - name: Terraform Destroy
        run: |
          echo " Destroying infrastructure..."
          terraform destroy -auto-approve
          echo " Infrastructure destroyed successfully"

      - name: Cleanup Artifacts
        run: |
          echo " Cleaning up sensitive artifacts..."
          rm -f private_key.pem
          echo " Cleanup completed"
